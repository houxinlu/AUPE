UNIX进程的环境

	引言
		本章将学习：当执行程序时，其main函数是如何被调用的，命令行参数是如何传送给执行程序的；
			    典型的存储器布局是什么样式；
			    如何分配另外的存储空间；
			    进程如何使用环境变量；		
			    进程终止的不同方式等；
			    longjmp和setjmp函数以及它们与栈的交互作用；
			    查看进程的资源限制；



	main函数
		C程序总是从main函数开始执行，main函数的原型是：
		int	main(int argc, char *argv[]);
		其中，argc是命令行参数的数目,argv是指向参数的各个指针所构成的数组。



	进程终止
		五种进程终止：
		（1）正常终止
		   （a）从main返回。
		   （b）调用exit。
		   （c）调用_exit。
		（2）异常终止：
		   （a）调用abort。
		   （b）由一个信号终止。



	exit()和_exit()
		exit和_exit函数用于正常终止一个程序：_exit立即进入内核，exit则先执行一些清除处理(包括调用执行各终止处理程序，关闭所有
		标准I/O流等)，然后进入内核。
		#include<stdlib.h>
		void  exit(int status);
		#include<unistd.h>
		void  _exit(int status);

		exit函数总是执行一个标准I/O库的清除关闭操作：对于所有打开流调用fclose函数。
		exit和_exit都带一个整型参数，称之为终止状态。大多数UNIXshell都提供检查一个进程终止状态的方法。
		有些代码,main函数没有使用return语句返回（隐式返回），这是不完整的。


		
	atexit()
		按照ANSIC的规定，一个进程可以等级多至32个函数，这些函数将由exit自动调用。我们称这些函数为终止处理程序，并用atexit()来
	      登记这些函数。
		#include<stdlib.h>
		
		int atexit(void (*func)(void));
		
		atexit的参数是一个函数地址，当调用此函数时无需向它传送任何参数，也不期望它返回一个值。
		exit以登记这些函数的相反顺序调用它们。

				图1	显示一个C程序时如何启动的，以及它终止的各种方式

			  ------------------------------------------------------------------
			 |								    |
		  _exit	 |     ——————				       ————————————	    |	
	       |<—————————————| 用户 |  \			 /——> |终止处理程序|	    |
	       |	 |    |	函数 |	 \		  (调用)/    / ————————————  	    |
	       |	 |     ——————     \  		       /    /			    |
	       |	 |     	|  ↑       \	 	      /	   /			    |
   	       |	 |      |  |        \exit（不返回）  /	  / (返回)		    |
	       |	 |(返回)|  |	     \              /    /			    |
	       |	 |	↓  |(调用)    \            /    /			    |
	       |    _exit|    ——————	       \↓ ——————  /    /	。。。		    |
	       ||<—————————— | main |   exit    | exit | <———	(调用)	  ———————————— 	    |
	       ||	 |   | 函数 |——————————>| 函数 | ——————————————>|终止处理程序|	    |   用户进程
	       ||	 |    ——————  (不返回)   ——————  <—————————————  ————————————       |
	       ||        |	|  ↑             /↑ |  ↑\ \	(返回)			    |
	       ||	 |(返回)|  |           /    |	  \ \				    |
	       ||	 |	|  |         / 	    |	    \ \(调用)			    |
	       ||	 |	↓  |(调用) / exit   |  (返回) \ \			    |
	       ||	 |     ——————	 / (不返回) |	        \ \			    |
	       ||	 |    |C启动 | /            |             \ \↓  ———————————	    |
	       ||	 |    |	例程 |   	    |		       |标准I/O清除|	    |
	       ||	 |     —————		    |		        ———————————	    |
	       ||	 |       ↑                  |					    |
	       ||	 |       |                  |_exit 				    |	
	       ||	 |-------|------------------|---------------------------------------|
	       ||		 |                  |
	       ↓↓	 	 |exec		    ↓
              —————————————————————————————————————————————————————————————————————————————————————
	     |			     								   |
	     |		                           内核						   |
	      —————————————————————————————————————————————————————————————————————————————————————




	命令行参数
		当执行一个程序时，调用exec的进程可将命令行参数传递给该新程序。
		示例的代码也非常简单，
		其主要的就是
		#include "outhdr.h"
		
		int
		main(int argc, char *argv[])	
		{
			for(i=0;argv[i]!=NULL;i++)		//ANSIC和POSIX,1都要求argv[argc]是一个空指针。所有循环可以这样写
		}
		


	环境表
		每个程序都接受到一张环境表。它也是一个字符指针数组，其中每个指针包含一个以null结束的字符串的地址。
		全局变量environ则包含了该指针数组的地址。
		extern	char  **environ;

			图1	由五个字符串组成的环境
			
		  环境指针		     环境表		  环境字符串
	environ:  —————————                 —————————
                 |         |  ————————————>|         |——————————> HOME=/home/stevens\0
	          —————————                 —————————
			  		   |  	     |——————————> PATH=:/bin:/usr/bin\0
					    —————————
					   |	     |——————————> SHELL=/bin/sh\0
					    —————————
					   |	     |——————————> USER=stevens\0
					    —————————
					   |	     |——————————> LOGNAME=stevens\0
					    —————————
					   |   NULL  |
					    —————————



	
	C程序的存储空间布局
		*正文段。这是由CPU执行的机器指定部分，通常，可共享，只读。
		*初始化数据段。包含了程序中需赋初值的变量。
		*非初始化数据段。bss段。内核将此段初始化为0。
		*栈。自动变量以及每次函数调用时所需保存的信息都存访在此段中。每次函数调用时其返回地址，以及调用者的环境信息都存访在栈
		中。然后，新被调用的函数在栈上为其自动和临时变量分配存储空间。通过以这种方式使用栈，C函数可以递归调用。
		*堆。通常在堆中进行动态存储分配。堆位于非初始化数据段顶和栈底之间。
		
		高地址	 ——————————————
			|	       |  命令行参数和环境变量
		         ——————————————
			|    栈	       |
		  	|----|---------|
			|    |	       |
			|    ↓	       |
			|	       |
			|    ↑	       |
			|    |	       |
		 	|--------------|
			|    堆	       |
			 ——————————————
			|未初始化的数据|    由exec赋初始值0
			 ——————————————
			|初始化的数据  |
			 ——————————————    exec从程序文件中读到
			|    正文      |
		低地址	 ——————————————

		size(1)命令报告正文段、数据段和bss段的长度。


	共享库
		很多UNIX系统支持共享库。
		共享库使得可执行文件中不再需要包含常用的库函数，而只需要在所有进程都可存取的存储区中保存这种库例程的一个副本。
		优点：
		    1：减少了每个可执行文件的长度，但增加了一些运行时间开销。
		    2：可以用库函数的新版本代替老版本而无需对使用该库的程序重新连接编辑。



	存储器分配
		ANSIC说明了三个用于存储空间动态分配的函数。
		（1）malloc。分配指定字节数的存储区。此存储区中的初始值不确定。
		（2）calloc。为指定长度的对象，分配能容纳其指定个数的存储空间。该空间中的每一位(bit)都初始化为0。
		（3）realloc。更改以前分配区的长度（增/减）。当增加长度时，可能需将以前分配去的内容移到另一个足够大的区域，而新增
		   区域内的初始值则不确定。
		 #include<stdlib.h>
		
		void  *malloc(size_t size);
		void  *calloc(size_t nobj, size_t size);
		void  *realloc(void *ptr, size_t newsize);

		void free(void *ptr)
		这三个分配函数所返回的指针一定时适当对齐的，使其可用于任何数据对象。函数free释放ptr指向的存储空间。

		还有一个值得提的函数 alloca。它与malloc的调用序列相同，但是它是在当前函数的栈帧上分配存储空间，而不是在堆中。




	环境变量
		环境字符串的形式是：  name=value
		ANSIC定义了一个函数getenv，可以用其取环境变量值。
		#include<stdlib.h>
		
		char  *getenv(const  char *name);
		注意：此函数返回一个指针，它指向name=value字符串中的value。我们应当使用getenv从环境中取一个环境变量的值，而不是直接
		    存取environ。

			        	表1	 	环境变量
			变量		标准		  实现			说明
				  POSIX.1   XPG3      SVR4    4.3+BSD
			HOME	    *	     *		*	*		起始目录
			LANG	    *	     *		*			本地名
			LC_ALL	    *	     *		*			本地名
			LC_COLLATE  *	     *	       	*			本地排序名
			LC_CTYPE    *	     *		*			本地字符分类名
			LC_MONETARY *	     *		*			本地货币编辑名
			LC_NUMERIC  *	     *		*			本地数字编辑名
			LC_TIME	    *	     *		*			本地日期/时间格式名
			LOGNAME	    *	     *		*     	*		登陆名
			NLSPATH	    *	     *		*			消息类模板序列
			PATH	    *	     *		*	*		搜索可执行文件的路径前缀表
			TERM	    *	     *		*	*		终端类型
			TZ	    *	     *		*	*	        时区信息

					表2	对于各种环境表函数的支持
			函数			标准				  实现	
				  ANSIC		POSIX.1		XPG3		SVR4	4.3+BSD
			getenv      *		   *		  *		  *	   *
			putenv	    		(可能)		  *		  *	   *
			setenv								   *
			unsetenv							   *
			clearenv	  	(可能)

			中间的三个函数的原型是：
			#include<stdlib.h>
			
			int putenv(const  char *str);
			int setenv(const  char *name, const char *value, int rewrite);
			void unsetenv(const char *name);


		
	setjmp和longjmp函数
		在C中，不允许使用跳跃函数的goto语句。而执行这种跳转功能的函数setjmp和longjmp。这两个函数对于处理发生在很深的嵌套
	      函数中的出错情况非常有用。
		示例举得例子就非常的形象，他进行了至少三个栈的堆积，但在其中需要进行打印一个出错信息（该错误信息并不致命），然后
	      继续连续执行下面的行为，如果使用检查返回值的方法逐层返回，则会非常麻烦，此时使用非局部跳转——setjmp和longjmp函数，就
	      会非常有用。
		#include<setjmp.h>
		
		int setjmp(jmp_buf env);
		
		void longjmp(jmp_buf env, int val);
		在系统返回的位置调用setjmp。 setjmp的参数env是一个特殊类型jmp_buf。这一数据类型是某种形式的数组，其中存访在调用
	      longjmp时能用来恢复栈状态的所有信息。一般，env变量是个全局变量，因为需从另一个函数中引用它。




	自动、寄存器和易失变量
		当longimp返回到main函数时，这些变量的值是否能恢复到以前调用setjmp时的值？这是不确定的
		如果你有一个自动变量，而又不想使其值滚回，则可定义其为具有volatile属性。说明为全局和静态变量的值在执行longjmp时保持不变。
		示例给的很清除，当数据在不优化时放在存储器中(亦即对val的寄存器存储类被忽略)。
		而进行优化时，count和val都存放在寄存器中，volatile变量则仍存访在存储器中。  所有对于的sum的值就没有改变（即易失变量不受
		优化的影响）



	自动变量的潜在问题
		数中的示例做了一个相当于”蛇自己吃自己“的实验，将给自己主函数分配的栈上分配了存储空间作为自身流的缓存。
		为了改正这一问题，应在全局存储空间静态地，或者动态地（使用一种alloc函数）为数中databuf分配空间。




	getrlimit和setrlimit函数
		每个进程都有一组资源限制，其中某一些可以用getrlimit和setrlimit函数查询和更改。
		#include<sys/time.h>
		#include<sys/resource.h>

		int  getrlimit(int resource, struct rlimit *rlptr);
		int  setrlimit(int resource, const struct rlimit *rlptr);
		对这两个函数的每一次调用都指定一个资源以及下列结构的指针：
		struct  rlimit {
		  rlim_t  rlim_cur;
		  rlim_t  rlim_max;
		}

		更改资源限制遵行的三条规则；
		(1)任何一个进程都可将一个软限制更改为小于或等于其硬限制；
		(2)任何一个进程都可降低其硬限制值，但他必须大于或等于其软限制值。这种降低，对于普通用户而言时不可逆反的。
		(3)只有超级用户可以提高硬限制。
		一个无限量的限制由常数RLIM_INFINITY指定。
		关于一些SVR4及4.3+BSD  归档资源限制 可以查询相关的记录。



		
















