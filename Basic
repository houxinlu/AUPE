
UNIX 基础知识

1.     登陆	
	登陆名所在文件/etc/passwd
               格式：
        	登录名:加密口令:数字用户ID（224）:数字组ID（20）:注释字段:起始目录:shell程序


	常用shell：
		Bourne shell   /bin/sh
		C	       /bin/csh
		KornShell      /bin/ksh
	    系统从口令文件中登录象的最后一个字段中了解到应该执行哪一个shell。

	
2.     文件和目录
 	文件系统：
		文件属性： 文件类型，文件长度，文件所有者，文件的许可权，文件最后的修改时间等。
		 stat和fstat函数返回一个包含所有文件属性的信息结构

	文件名：filename，UNIX系统限制文件名最大长度14个字符，BSD扩展为255个字符
		（文件名不可出现 斜线（/）和空操作符（null））

	路径名： 分为绝对路径和相对路径。

	ls(1)示例代码： 
		* 头文件ourhdr.h  几乎本书的每一个程序都包含此头文件。它包含了某些标准系统头文件，
		* 定义了许多常数及函数原型 
		* 取命令的第一个参数argv[1]作为列出的目录名
		* 常用的操作目录的函数opendir,readdir,closedir
		*  opendir函数返回指向DIR结构的指针，并将该指针转向readdir函数。然后再循环中调用
		  readdir来读每个目录项。它返回一个指向dirent结构的指针，而当目录中已无目录项可读
		  时返回null指针。在dirent结构中取出的知识每个目录项的名字（d_name）。使用该名字，
		  此后就可调用stat函数以决定该文件的所有属性
                *  调用了两个自编函数进行错误处理：err_sys和err_quit，对指针内容判断，判断是否存在或
		  非目录错误。
		* 当程序结束时，它以参数0调用函数exit,表示正常退出。    

	工作目录：每个进程都有一个工作目录（working directory），有时称为当前工作目录（current working
		 directory）。进程可以用chdir函数更改其工作目录。
	
	起始目录（home directory）

3.     输入和输出

        文件描述符：  文件描述符是一个小的非负整数，内核用以标识一个特定进程正在存访的文件。当内核打开
                    一个现存文件或创建一个新文件时，它就返回一个文件描述符。当读，写文件时，就可使用它。

        标准输入、标准输入和标准出错：  按惯例，每当运行一个新程序时，所有的shell都为其打开三个文件描述符：
                                     标准输入、标准输入和标准输出。
                                        大多shell都提供一种方法，例如 ls > file.list  执行ls命令，
                                     其标准输出重新定向到名为file.list的文件上。

        不用缓存的I/O:   函数open、read、write、lseek以及close提供了不用缓存的I/O。
      
        标准I/O:	使用标准I/O无需担心如何选取最佳的缓存长度，而且它的另一个优点与处理输入行有关。
                     例如：fget()函数读一完整的行，而另一方面，read()函数读指定字节数 

4.     程序和进程

        程序（program）存放在磁盘的可执行文件。使用6个exec函数中的一个由内核将程序读入存储器，并使其执行

        进程和进程ID：   程序的执行实例被称为进程（process）
                         每个UNIX进程都一定有一个唯一的数字标识符，称为（process ID）
                         使用getpid()函数得到进程ID

        进程控制：  三个主要函数： fork,exec和waitpid(exec函数有六种变体，但进场把它们统称为exec函数。
   
        示例分析：

5.     ANSIC   本书中所有实例都用ANSIC编写

        函数原型： 初章节学习的头文件<unistd.h>包含了许多UNIX系统服务的函数原型，
                 例如：read , write和getpid
                       ssize_t    read(int,void *,size_t);
                       ssize_t    write(int,const_void *,size_t);
		       pid_t	  getpid(void)  

        类属指针： read和write第二个参数现在是void * 类型。ANSIC使用void *代替char *   (函数原型和类属指针
                 的组合消去了很多非ANSIC编辑程序需要的显式类型强制转换)
        
        原始系统数据类型：  以_t结尾的这些数据类型被称为原始系统数据类型。
　　                    它的含义即为：采用统一的说明，目的是阻止程序使用专门的数据类型（int,short或long）来
                                   允许对一个特定系统的函数数据类型进行更改。

6.     出错处理
	当UNIX函数出错时，往常返回一个负值，整型变量errno通常设置为具有特定信息的一个值（没有打开所要求
      文件的权限 errno = EACCES）。  
　　    在open（）出错时，有大约15个不同的errno值（文件不存在，权限问题等），这些值/常数 都以E开头，另外
      intro（2）列出了所有这些出错常数。

　　    Erron的两条规则：
                 （1） 如果没有出错，则其值不会被一个例程清除，因此，仅当函数返回值指明出错时，才检验其值。
                 （2） 任何函数都不会将errno值设置为0，在<errno.h>中定义的所有常数都不为0

        C标准定义了两个函数，他们帮助打印出错信息
                  (1) #include<string.h>
                      char *strerror(int errnum)
　　                此函数将errnum（它通常就是errno值）映射为一个出错信息字符串，并且返回此字符串的指针，示例
                中就将它的值赋为EACCES
                  (2)#include<stdio.h>
　　		      void perror(const char msg)
　　                perror函数在标准出错上产生一条出错消息（基于errno的当前值），然后返回。
　　            它首先输出msg指向的字符串，然后是一个冒号，一个空格，然后是对应于errno值的出错信息，然后是一个新行符。
　　   
　　    示例给的非常明确，结果也非常清晰
　　             fprintf(stdrr,”EACCESS:%s\n”,strerror(EACCES));
　　             errno = ENOENT;    // ENOENT 是文件不存在的常数
　　             perror(argv[0]);   // 将程序名（argv[0]，即a.out）作为参数传递给perror
　　                                //  这是一个标准的UNIX惯例。

7.     用户标识
        
        用户ID:  口令文件登陆项中的用户ID(userID)是个数值，它向系统标识各个不同的用户。通常每个用户有一个唯一的用户ID
                 ID为0的用户为根(root)或超级用户(superuser),
                 getuid(),getgid   调用getuid()和getgid() 以返回用户ID和组ID

          组ID： 口令文件登陆项也包括用户的组ID(group ID),它也是一个数值。同组下的用户之间可以共享资源(例如文件等)  
                 组文件将组名映射为数字组ID，它通常是/etc/group
   
        添加组ID: groupadd 命令可以为用户添加组，某些UNIX版本还允许一个用户属于另外一些组。从4.2BSD开始，它允许一个
                  用户属于多至16个另外的组。

8.     信号
            在以往学习的过程中，信号机制非常的重要，简单来说 信号是通知进程已发生某种条件的一种技术。本节的介绍重点
          在于信号的处理
        
            （1）忽略该信号。例如 有些信号表示硬件异常，因为这些异常产生的后果不确定，所以不推荐使用这种处理方式。
            （2）按系统默认方式处理。 对于0除，这种定理型的错误，系统默认方式是终止该进程。
            （3）提供一个函数，信号发生时则调用该函数。使用这种方式，我们将能指导什么时候产生了信号，并按所希望的
                 方式处理它。
            有很多条件会产生信号。 两种键盘方式，分别称为中断键（Delete键或Ctrl-C）和退出键（quit key或Ctrl-\）

             本节示例 将1-5示例进行了添加，添加了signal函数，指定当产生SIGNINT信号时要调用的函数名。相当于检测系统
           信号，然后每当系统信号出发时，调用自己编写的sig_int函数，printf一行提示信息。

9.     UNIX时间值
            (1)日历时间： 该值是自1970年1月1日00:00:00以来国际标准时间(UTC)所经过的秒数累积值，早期称为格林尼治时间
                         这些时间值可用于记录文件最近一次的修改时间等。

            (2)进程时间： 这也被称为CPU时间，用以度量进程使用的中央处理机资源。系统基本数据类型clock_t保存这种时间值，
                         另外，POSIX定义常数CLK_TCK，用其说明每秒滴答数。
  
            当度量一个进程的执行时间时，UNIX系统使用三个进程时间值：
                  
		   *时钟时间（wall clock time）
                   它是进程运行的时间总量，其值与系统中同时进行的进程数有关。
                                
                   *用户CPU时间
                   它是执行用户指令所用的时间量。

                   *系统CPU时间
		   它是为该进程执行内核所经历的时间。
            要取得任一进程的时钟时间、用户时间和系统时间很容易————只要执行命令time      
          
10.	系统调用和库函数
            就我对本节的简单理解，垂直空间来说  应用代码 ——> 库函数 ——> 系统调用

            理论上来说，程序员的变成主要是接触到自定义函数和库函数，而所以的系统调用由库函数进行操作
               例如： 内存分配      应用代码 <——> 存储分配函数 <——> sbrk 系统调用
                                        |                  |           |
                                        |————用户进程——————|           |——————内核部分...   

















  

































