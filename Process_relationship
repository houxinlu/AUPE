进程关系

	引言
		本章更详细地说明进程组以及POSIX.1引进的对话其新概念。
		介绍登陆shell和所有从登陆shell启动的进程之间的关系
		这章应和第十章一起看，涉及到了很多信号的问题。(还是提前把这两章看完再做笔记的好！！！)


	
	终端登陆
		实际上，终端登陆在我的理解上是个非常复杂的过程，即使看完整个章节包括后面4.3+BSD实现。
		但是本章也尽力阐述和使用简图进行了表现。
		
		历史太久远的终端登陆本章也没有细节的阐述，所以就不用再细节的提及了。
	  	
		4.3+BSD终端登陆
		   前提：系统管理者创建一个通常名为/etc/ttys的文件，其中没个终端设备有一行，每一行说明设备名和传到getty程序的参数，
		       这些参数说明了终端的波特率等。
		   起始：当系统自举时，内核创建进程ID 1(init进程)。init进程使系统进入多用户状态。
		   进行：init读文件/etc/ttys，对每一个允许登陆的终端设备，init调用一次fork，它所生成的子进程则执行程序getty。

			进程 ID 1					进程ID 1						进程ID 1	
			————————					 ———————  读/etc/ttys;					——————
		       |  init  |					| init	| 对每个终端fork一次创建空环境		       | init |
		     /	————————  \				       / ——————— \ 						——————
		    /	    |	   \				      /	    |	  \		  				   | 
		   /	    |fork   \	  对每个终端fork一次         /      |fork  \         					   |     通过getty和login
		  ↓	    ↓        ↓				    ↓	    ↓	    ↓						   ↓
			————————					  ——————						———————————
		       |  init	|					 | init |					       | 登陆shell |
			————————					  ——————						———————————
			    |		    每个子进程			     | 							    ↑
			    |exec	    exec getty			     | exec						    | fd 0,1,2
			    ↓						     ↓							    ↓ 
			 ———————					   —————						 ——————————
			| getty	|					  |getty|  打开终端设备					| 终端设备 |
			 ———————					   —————    读用户名 					| 驱动程序 |
									     |	   初始化环境设置				 ——————————
		图1 init生成进程使终端可用于登陆			     | exec						     ↑
									     ↓							     |  RS-232连接
									   ———————						     ↓
									  | login |						 ______________
									   ———————						|使用终端的用户|
								 图2  login刚被调用后各进程的状态				————————————————
															   图3 终端登陆结束后的有关进位

		其实，实际的流程肯定更为复杂，如果设计登陆相关的算法的化，可以深入学习的。


		SVR4终端登陆
			SVR4支持两种形成的终端登陆：(a)getty方式，这与上面对4.3+BSD所说明的一样。
						    (b)ttymon登陆，ttymon是名为服务存取设施的一部分。ttymon监视列于配置文件中的所有终端端口，当用户键入登陆名时，
						       它调用一次fork。




	网络登陆
		4.3+BSD网络登录
			网络登录时，所有登陆都经由内核的网络界面驱动程序（例如：以太网驱动程序）。
			在该类型的网络登陆中，有一个称为inetd的进程（有时称为Internet superserver）,他等待大多数网络连接。
		        
			大概的流程：   作为系统启动的一部分，init调用一个shell，使其执行shell脚本etc/rc。由此shell脚本启动一个精灵进程inetd。
				    一旦此shell脚本终止，inetd的父进程就变成init.inetd等待TCP/IP连接请求到达主机，而当一个连接请求到达时，它
				    执行一次fork,然后该子进程执行适当的程序。

			吐槽：在shell中画图时最耗费时间的啊！！！！
					
					进程 ID 1					    进程ID 1
					——————						    ——————
				       | init |						   | init |
					——————						    ——————
					  |    fork并执行(exec)/bin/sh,			      |       通过inetd,telnetd.和login
					  |    在系统进入多用户方式时 			      | 
					  |    它解释执行/etc/rc			      |
					  ↓						      ↓
		  来自TELNET客户        ———————						    ———————————
		—————————————————————> | inetd |					   | 登陆shell |		
		  的TCP连接请求		———————						    ———————————
					  |							↑
					  | fork   来自TELNET客户的				| fd 0,1,2
					  ↓	   连接请求到达时				↓
				        ———————						     ————————————
				       | inetd |					    | 伪终端设备 |
					———————						    |  驱动程序	 |	
					  |						     ————————————	
					  | exec						  ↑	
					  ↓							  |	telnetd服务器和telnet客户之间的网络连接	
				 	—————————						  |		
				       | telnetd |						  ↓
					—————————				             ______________
									         	    |使用终端的用户|
			图1 执行TELENET服务进程中设计的进程序列				     ——————————————
											图2  为网络登陆设置了fd 0,1,2后的进程安排

		  很明显，在为终端设备驱动程序和终端实际用户之间由很多事情在进行着。


		SVR4网络登陆
			与4.3+BSD中的几乎一样。同样使用了inetd服务器进程，但是在SVR4中inetd是作为一种服务由服务存取控制器sac调用的，其父进程不是init。



	
	进程组
		每个进程除了有一进程ID之外，还属于一个进程组。
		进程组是一个或多个进程的集合。每个进程组有一个唯一的进程组ID。

		函数getpgrp返回调用进程的进程组ID。
		#include<sys/types.h>
		#include<unistd.h>

		pid_t  getpgrp(void);

		每个进程组有一个组长进程。组长进程的标识是，其进程组ID等于其进程ID。
		只要有进程，进程组就存在。 
		某个进程组的最后一个进程可以终止，也可以参加另一个进程组。

		进程调用setpgid可以参加一个现存的组或者创建一个新进程组。
		#include<sys/types.h>
		#include<unistd.h>

		int setpgid(pid_t pid, pid_t pgid);
		这将pid进程的进程组ID设置为pgid。如果这两个参数相等，则由pid指定的进程变成进程组组长。

		在作业控制中，因为牵扯到父，子进程在进程组中执行作业，进而会产生竞态条件，所有还得靠后续的信号相关的知识点进行处理。		
		


	对话期
		对话期是一个或多个进程组的集合。
		在一个对话期中有三个进程组。通常是由shell的管道线将几个进程编成一组的。
			
		 ———————————	      ————————   ———————      	   ————————   ————————
		| 登陆shell |   ——>  | proc 1 | | proc2 |  ————>  | proc 3 | | proc 4 | 
		 ———————————	      ————————   ———————	   ————————   ————————
									 ————————
								        | proc 5 |	
									 ————————
				
					图1 进程组和对话期中的进程安排
					（其也就是个简化图）

		进程调用setsid函数就可以建立一个新对话期。
		#include<sys/types.h>
		#include<unistd.h>

		pid_t	setsid(void);

		如果调用此函数的进程不是一个进程组的组长，则此函数创建一个新对话期，结果为：
		(1)此进程编成该对话期的对话期首进程。此进程是该新对话期中的唯一希望。
		(2)此进程成为一个新进程组的组长进程。新进程组ID是此调用进程的进程ID。
		(3)此进程没有控制终端。

	

	
	控制终端
		对话期和进程组有一些其他特性：
		*一个对话期可以用一个单独的控制终端。通常的终端设备(终端登陆情况)或伪终端设备(网络登陆情况)。
		*建立与控制终端连接的对话期首进程，被称之为控制终端。
		*一个对话期中的几个进程组可被分成一个前台进程组以及一个或几个后台进程组。
		*如果一个对话期有一个控制终端，则它有一个前台进程组，其他进程组则为后台进程组。
		*无论何时键入终端键（DELETE或Ctrl-C）或推出键（Ctrl-\）,就会造成将中断信号或推出信号送至前台进程组的所有进程。
		*如果终端界面检测到调制解调器已经脱开连接，则将挂断信号送至控制信号。

					对话期
	 	 ——————————————————————————————————————————————————————————————————————————
		|                     
		|	—————————    |   ————————    ————————    |   ————————   ————————
		|      |登陆shell|   |  | proc 1 |  | proc 2 |	 |  | proc 3 | | proc 4 |
		|       —————————    |   ————————    ————————    |   ————————   ————————
		|          	     |   			 |         ————————
		|  		     |				 |	  | proc 5 |
		|      后台进程组    |	    后台进程组		 |	   —————————
		|      对话期首进程  |				 |        前台进程组
		|      =控制进程     |				 |
				\↑                                  ↑ /
			     	 \			            /
				  \调制调制器脱开连接             /
				   \				/终端输入和终端产生的信号
			(挂断信号)  \			      /  
				     \			    /
				      \			  /
				       \		/
					  控制器终端
				图1 进程组、对话期和控制终端

			有时不管标准输入、标准输出是否重新定向，程序都要与控制终端交互作用。


	
	tcgetpgrp和tcsetpgrp函数
		需要有一种方法来同志内核哪一个进程组是前台进程组，这样，终端设备驱动程序就能了解将终端输入和终端产生的信号送到何处。
		#include<sys/types.h>
		#include<unistd.h>

		pid_t  tcgetpgrp(int filedes);

		int  tcsetpgrp(int filedes, pid_t pgrpid);
		函数tcgetpgrp返回前台进程组ID，它与在filedes上打开的终端相关。



	作业控制
		它允许在一个终端上启动多个作业（进程组），控制哪一个作业可以存取该终端，以及那些作业在后台运行。
		作业控制要求的三种形式的支持：
		（1）支持作业控制的shell。
		（2）内核中的终端驱动程序必须支持作业控制。
		（3）必须提供对某些作业控制信号的支持。



	shell 执行程序
		让我们检验以下shell是如何执行程序的，以及这与进程组，控制终端和对话期等概念的关系。
		
		
		图9-8 对于前台、后台作业以及终端驱动程序的作业控制功能摘要
		
		文中采用了 ps -xj     
			   ps -xj &
			   ps -xj | cat1
	                   ps -xj | cat1 &
		等命令，查看了PPID PID PGID SID TPGID  COMMAND    命令之间的父子等关系。





	孤儿进程组
		一个父进程已终止的进程成为孤儿进程，这种进程由init进程收养。现状我们要说明整个进程组也可成为孤儿，以及POSIX.1如何处理它。

		在书中本小节作业一个孤儿进程的更加深入的分析，父进程终止时，如果该子进程停止（用作业控制方法）结果将如何？子进程如何继续
		以及子进程是否知道它已经是孤儿进程。

		假定使用一个作业控制shell，shell将前台进程放在一个进程组中。在fork后：
		*父进程睡眠5秒，让子进程在父进程之前运行。
		*子进程 发送一个挂断信号（SIGHUP）。
		*子进程用kill函数向其自身发送停止信号（SIGTSTP）。这停止了子进程，类似于用终端挂起字符（Ctrl-Z）停止一个前台作业。
		*当父进程终止时，该子进程成为孤儿进程，其父进程ID成为1。
		*现在，子进程成为一个孤儿进程组的成员。
		POSIX.1将孤儿进程组定义为：该组中每个成员的父进程或者是该组的一个成员，成员，或者不是该组所属对话期的成员。
		*因为在父进程终止后，进程组成为孤儿进程组。
		*在处理了挂断信号后，子进程继续。



	4.3+BSD实现
		下面简要说明4.3+BSD的实现


					图9-11 对话期和进程组的4.3+BSD实现

		下面说明图中的各个字段。从session结构开始。每个对话期都分配了这样一种结构。
		*s_count是该对话期中的进程组数组。当此计数器减至0时，则可释放此结构。
		*s_leader是指向对话期首进程proc结构的指针。
		*s_ttyvp是指向控制终端vnode结构的指针。
		*s_ttyp是指向控制终端tty结构的指针。
		*t_session指向将此终端作为控制终端的session结构。终端在失去载波信号时使用此指针将挂起信号送给对话期首进程。
		*t_pgrp指向前台进程组的pgrp结构。终端驱动程序用此字段将信号送向前台进程组。由输入特殊字符（终端、推出和挂起）而产生的三
	      个信号被送至前台进程组。
		*t_termios是包含所有这些特殊字符和与该终端有关信息（例如：波特率、回送打开或关闭等）的结构。
		*t_winsize是包含终端窗口当前尺寸的winsize结构。当终端窗口尺寸改变时，信号SIGWINCH被送至前台进程组。
		pgrp结构包含一个进程组的信息。
		*pg_id是进程组ID。
		*pg_session指向此进程组所属的session结构。
		*pg_mem是指向此进程组第一个进程proc结构的指针。proc结构中的p_pgrpnxt指向此组中的下一个进程，进程组中最后一个进程proc中的
	     p_pgrpnxt则为空指针。
		proc结构包含一个进程的所有信息。
		*p_pid包含进程ID。
		*p_pptr是指向父进程proc结构的指针。
		*p_pgrp指向本进程所属的进程组的pgrp结构。
		*p_pgrpnxt是指向进程组中下一个进程的指针
