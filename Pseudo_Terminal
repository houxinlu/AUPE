伪终端

	概述
		伪终端 这个名词暗示了与一个应用程序相比，它更加像一个终端。但是伪终端并不是一个真正的终端。
		（我感觉书上这句话就是一句废话）

					   fork
				用户进程  ———————> 用户进程
				   ↑	   exec       ↑
			 	   |                  | stdin,stdout
			    ----------------------------------------
				   |		      |
				   ↓                  ↓
				读、写函数         读、写函数
				  |   ↑		     |   ↑
				  |   |		     ↓   |
				  |   |            终端行规程
				  |   |              |   ↑
			  	  |   |		     ↓   |
				伪终端主设备      伪终端从设备
				  |   ↑←—————————————↓   ↑
				  ↓_____________________→|

				图  典型的伪终端进程结构


		（1）通常一个进程打开伪终端主设备然后调用fork。子进程建立了一个新的对话，打开一个相应的伪终端从设备，
		     将它复制成标准输入、标准输出和标准出错，然后调用exec。伪终端从设备成为子进程的控制终端。

		（2）对于伪终端从设备之上的用户进程来说，其标准输入、标准输出和标准出错都能当作终端设备使用。

		（3）任何写到伪终端主设备的输入都会作为从设备端的输入，反之亦然。


	网络登陆服务器
		伪终端用于构造网络登陆服务器。 典型的例证是telnetd和rlogind服务器。
		在rlogind服务器和登陆shell之间有两个exec调用，这是因为Login程序通常是在两个exec之间检验用户是否合法的。
		本图的一个关键点是驱动伪终端主设备的进程通常同时在读写另一个I/O流。
 					           fork
				rlogind服务器  ————————————> 登陆shell
			       /  ↑	| ↑	exec、exec     |  ↑
			      /  /      | |            标准输出|  |标准输入
			-----|--|-------------------------------------------------
			     ↓  |       | | 	       标准出错|  |              
			  TCP/IP协议    | |                    ↓  |          
			     | 	↑	| |		    终端行规程                 内核
			     |  |       | |                    |  ↑
			     ↓  |       | |                    |  |
			   网络设备	↓ |                    ↓  | 
			      ↑	      pty主设备              pty从设备
			      |		| ↑ 		       ↓  ↑
			      |		↓  ←————————————————————  |
			      |	         ————————————————————————→
                              |
                              ↓
			     网络

				   图   rlogind服务器的进程组织结构




	script程序
		script程序是随SVR4和4.3+BSD提供的，该程序将终端对话期间所有的输入和输出信息在一个文件中做一个拷贝。

						script
					         文件	
					          ↑
				  fork		  |              fork
			登陆  —————————————> script  process ————————————> shell
		       shell	  exec       |  ↑     |  ↑       exec      |  ↑
		      (休眠中)		     |  |     |  |          stdout |  | stdin
					     |  |     |  |	    stderr |  |
			---------------------------------------------------|  |---|
				             ↓  |     |  |                 ↓  |
                                          终端行规程  |  |              终端行规程
					     |  ↑     |  |                 |  ↑             内核
					     ↓  |     ↓  |                 ↓  |
				       终端设备驱动  pty主设备		pty从设备
					    ↑	      ↓  ↑_________________↓  ↑
					    |	       ———————————————————————
			     ------------------------------------------------------|    
                                            ↓
					终端上的用户




	expect程序
		伪终端可以用来使交互式的程序运行在非交互的状态中。
		expect程序提供了类似于pty程序的方法，他使用伪终端来运行其他程序。
		并且，expect还提供了一种编成语言用于检查程序的输出，以确定用什么作为输入发送给该程序。



	运行协同进程
		现在协同进程的标准输入和标准输出就像终端设备一样，所以标准I/O库会将这两个流设置为行缓存。
		父进程有两种不同的方法在自身和协同进程之间获得伪终端。
		一个方法是父进程直接调用pty_fork函数而不是fork。
		另一种方法是exec该pty程序，将协同进程作为参数。




	打开伪终端设备
		我们提供两个函数来处理所有细节：ptym_open用来打开下一个有效的伪终端主设备，ptys_open用来打开相应的从设备。

		#include "ourhdr.h"

		int  ptym_open(char *pts_name);
		
		int  ptys_open(int fdm, char *pts_name);
		通常我们不直接调用这两个函数——函数pty_fork调用它们并fork出一个子进程。

		ptym_open 决定下一个有效的伪终端主设备打开该设备。




	pty_fork函数
		现在使用上节介绍的两个函数：ptym_open和ptys_open，编写我们称之为pty_fork的函数。

		这个新函数具有如下功能：打开主设备和从设备，建立作为对话期管理者的子进程并使其具有控制终端。

		#include<sys/types.h>
		#include<termios.h>
		#include<sys/ioctl.h>
		#include "ourhdr.h"

		pid_t pty_fork(int *ptrfdm, char *slave_name,
				const  struct  termios  *slave_termios,
				const  struct  winsize  *slava_winsize);


本章以文中主要实现的pyt函数进行 实例学习，非常受用
